from sklearn.mixture import GaussianMixture
from scipy.stats import gaussian_kde
resolution='5min'
omp_tolerance = .06
#############################################################################################
##--------------------------- Visual identification of the HP -----------------------------##
#############################################################################################

# power_box=pd.DataFrame([[6880,2.5,3.2],
# [6995,None,None],
# [7477, 2.4,2.6],
# [7594,2.,3.],
# [9770,2.,3.],
# [9956,1.5,2],
# [10990,1.5,2.],
# [11978,2.75,3.25],
# [12712,2.,2.5],
# [12734,1.8,2.2],
# [12811,2.5,3.1],
# [12825,2.5,3.],
# [12861,1.5,2.2],
# [12883,3.2,4.5],
# [13093,None,None],
# [13421,2.75,3.25],
# [13544,1.8,3.],
# [14299,3.,4.],
# [15166,1.75,2.2],
# [15322,2.5,3.],
# [15675,1.75,2.25],
# [15908,2.5,3.],
# [16082,1.8,2.5],
# [16614,1.8,2.8],
# [16728,3.8,4.75],
# [17462,2.,3.],
# [17495,2.8,4.2],
# [17529,2.8,4.5],
# [17842,2.,3.],
# [17973,5.,6.],
# [18172,3.5,5.],
# [18589,1.8,2.2],
# [19039,3.,4.5],
# [19286,3.,3.5],
# [19345,2.5,3.],
# [19643,2.5,3.],
# [20046,1.5,2.],
# [20124,1.8,2.5],
# [20311,2.,3.],
# [21845,2.5,3.],
# [21964,3.,3.5],
# [22376,1.75,2.25],
# [22804,2.,3.],
# [23057,2.5,3.],
# [23438,2.5,3.],
# [23467,2.5,3.],
# [23583,None,None],
# [28398,2.5,3.],
# [28661,2.,3.],
# [28736,3.,4.5],
# [28961,None,None],
# [13565,1.5,3.],
# [18741,2.5,3.],
# [12731,3.7,4.4],
# [18204,1.75,2.25],
# [20629,2.5,3.],
# [7341,1.8,2.5],
# [9643,1.9,2.2],
# [16794,1.8,2.2]])
# power_box.set_index(0, inplace=True)



power_box=pd.DataFrame([[6880,2.3,3.2],
[6995,None,None],
[7477, 2.3,2.7],
[7594,2.,3.],
[9770,2.,3.],
[9956,1.4,2.1],
[10990,1.5,2.],
[11978,2.7,3.3],
[12712,1.9,2.6],
[12734,1.8,2.2],
[12811,2.4,3.2],
[12825,2.4,3.1],
[12861,1.4,2.3],
[12883,3.2,4.5],
[13093,None,None],
[13421,2.6,3.3],
[13544,1.7,3.1],
[14299,2.9,4.1],
[15166,1.6,2.3],
[15322,2.4,3.1],
[15675,1.7,2.3],
[15908,2.4,3.1],
[16082,1.7,2.6],
[16614,1.7,2.9],
[16728,3.8,4.75],
[17462,2.,3.],
[17495,2.7,4.2],
[17529,2.8,4.5],
[17842,1.9,3.1],
[17973,4.9,6.1],
[18172,3.4,5.1],
[18589,1.8,2.2],
[19039,2.9,4.5],
[19286,2.8,3.7],
[19345,2.4,3.1],
[19643,2.4,3.2],
[20046,1.4,2.4],
[20124,1.7,2.7],
[20311,1.9,3.1],
[21845,2.4,3.2],
[21964,2.9,3.6],
[22376,1.6,2.3],
[22804,2.,3.],
[23057,2.4,3.2],
[23438,2.4,3.2],
[23467,2.5,3.],
[23583,None,None],
[28398,2.4,3.2],
[28661,1.9,3.1],
[28736,3.,4.5],
[28961,None,None],
[13565,1.5,3.],
[18741,2.4,3.1],
[12731,3.5,4.5],
[18204,1.6,2.4],
[20629,2.5,3.],
[7341,1.6,2.6],
[9643,1.9,2.3],
[16794,1.6,2.5]])
power_box.set_index(0, inplace=True)



output=open(path2store+'/'+resolution+'/'+'gmm_output_omp-{}-{}.pickle'.format(omp_tolerance,resolution),'rb')
gmm_output=pickle.load(output)
output.close()


not_used=np.array([6995,10990,12734,13093,17462,18589,23583,28961,12883,28736])
#########################################################################################
#                                                                                       #
#-------- Extract power, OT and frequency from boxcar generated by the hp --------------#
#                                                                                       #
#########################################################################################
OT={}
power={}
for index, row in power_box.iterrows(): 

    if not any(not_used==index):
     
        mask=np.array(gmm_output[index]['centroids'].index[(np.max(gmm_output[index]['centroids'],axis=1)>row[1])&
            (np.max(gmm_output[index]['centroids'],axis=1)<row[2])])

        path=path2store+'/'+resolution+'/'+'houseID_{}-omp_{}-{}.pickle'.format(index,omp_tolerance,resolution)
        output=open(path, 'rb')
        resultDic = pickle.load(output)
        output.close()

        Kcoef_full = np.transpose(Kcoef_hstack_set(Xshape=1000, resultDic=resultDic))

        print( index)
        for j in mask:
            if np.any(np.count_nonzero(Kcoef_full[np.where(gmm_output[index]['REFIND']==j)[0]],axis=1)==0):
                print(j)
        #OT.extend(np.concatenate([np.count_nonzero(Kcoef_full[np.where(gmm_output[index]['REFIND']==j)[0]],axis=1) for j in mask]))
        #power.extend(np.concatenate([np.max(Kcoef_full[np.where(gmm_output[index]['REFIND']==j)[0]],axis=1) for j in mask]))
        OT[index]=np.concatenate([np.count_nonzero(Kcoef_full[np.where(gmm_output[index]['REFIND']==j)[0]],axis=1) for j in mask])
        power[index]=np.concatenate([np.max(Kcoef_full[np.where(gmm_output[index]['REFIND']==j)[0]],axis=1) for j in mask])

        to_delete=np.where((power[index]<row[1]-0.1)| (power[index]>row[2]+0.1))[0]

        power[index]=np.delete(power[index],to_delete,None)
        OT[index]=np.delete(OT[index],to_delete,None)



power_size={}
for i in power.keys():
#    xs=np.linspace(0,7,500) 
#    density_power = gaussian_kde(power[i])
    power_size[i]=np.argmin(np.abs(np.mean(power[i])-means_p))
    
nb_boxcar=pd.DataFrame(np.array([[k,len(v)] for k,v in power.items()]))

#for i in np.fromiter(power.keys(), dtype=int)[np.where(np.array(power_size)==0)[0]]:
#    density_power = gaussian_kde(power[i])
#   plt.plot(xs,density_power(xs),'-b',alpha=0.5)


#plt.plot(all_group[(all_group.index.get_level_values('to_ts')>'2014-12-26' )&(all_group.index.get_level_values('to_ts')<'2015-01-01')]['2MT'].values-273.15)

####################################################################
########### fit the distribution on the power and plots ############
####################################################################
all_power_data=np.concatenate([power[i] for i in power.keys()])
gmm_power=GaussianMixture(n_components=5,covariance_type='full').fit(all_power_data.reshape(-1,1))

### graph directly out of gmm ####
xs=np.linspace(0,6,500)
plt.plot(xs,np.sum(np.array([scistat.norm.pdf(xs,gmm_power.means_[i][0],gmm_power.covariances_[i][0][0])*gmm_power.weights_[i] for i in range(5)]),axis=0),'r')
plt.hist(all_power_data,density=True,bins=40)
plt.xlabel('Power [kW]')
plt.legend()

######## modified to fit better ############
#vars_p=np.array([0.074, 0.060, 0.1, 0.039, 0.22])#np.array([0.22, 0.2, 0.32,0.26])
#means_p=np.array([3.0, 2.0, 4.0, 2.60, 5.0])#np.array([3.3 ,2.65,4.08,2.05])
#weights_p=np.array([0.21, 0.27, 0.12, 0.38, 0.018])#np.array([0.12, 0.42 , 0.14, 0.32])
############# 5min ############################
vars_p=np.array([ 0.22, 0.16, 0.2, 0.35,  0.22])#np.array([0.22, 0.2, 0.32,0.26])
means_p=np.array([ 2.0,2.50, 3.0, 4.1, 5.0])#np.array([3.3 ,2.65,4.08,2.05])
weights_p=np.array([ 0.26,0.34,0.26, 0.12,  0.018])#np.array([0.12, 0.42 , 0.14, 0.32])
############################################

############################################
##### graphs with modified values ##########
xs=np.linspace(0,6,500) 
plt.hist(all_power_data,density=True,bins=40,alpha=0.75)
for i in range(5):
    plt.plot(xs,scistat.norm.pdf(xs,means_p[i],vars_p[i])*weights_p[i],label=r'$\mu_{}={}$'.format(i+1,np.round(means_p[i],2)))
plt.plot(xs,np.sum(np.array([scistat.norm.pdf(xs,means_p[i],vars_p[i])*weights_p[i] for i in range(5)]),axis=0),'black', label='Gaussian Mixture')

plt.xlabel('Power [kW]')
plt.legend()

#########################################################
###########  fit the distribution on the OT  ############
#########################################################
all_OT_data=np.log(np.concatenate([OT[i] for i in OT.keys()])*float(''.join(c for c in resolution if c.isdigit())) )
xs=np.linspace(0,7,500) 
#(exp1, k1, loc1, lam1)=scistat.exponweib.fit(all_OT_data)
#plt.plot(xs,scistat.exponweib.pdf(xs,exp1,k1,loc1,lam1),'-r',label='weibull')
#(u_OT,s_OT)=scistat.norm.fit(all_OT_data)
#plt.plot(xs,scistat.norm.pdf(xs,u_OT,s_OT),'-g',label='normal')
#(s_OT,u_OT,sc_OT)=scistat.lognorm.fit(all_OT_data)
#plt.plot(xs,scistat.lognorm.pdf(xs,s_OT,u_OT,sc_OT),'blue',label='lognormal')
(s_OT,u_OT,sc_OT)=scistat.exponnorm.fit(all_OT_data)
plt.plot(xs,scistat.exponnorm.pdf(xs,s_OT,u_OT,sc_OT),'black',label='expnormal')
plt.hist(all_OT_data,density=True,bins=15)
plt.xlabel('Operation Time [log(min)]')
plt.legend()
xs=np.linspace(0,8,500)




cond_OT={}
for j in range(5): 
    sub_OT=np.log(np.concatenate([OT[i] for i in [k for k, v in power_size.items() if v==j]])*5)
    plt.hist(sub_OT,bins=10,alpha=0.5,density=True)
    #if j!=3:

    cond_OT[j]=scistat.lognorm.fit(sub_OT)
    plt.plot(xs,scistat.lognorm.pdf(xs,cond_OT[j][0],cond_OT[j][1],cond_OT[j][2]),label='lognormal'+str(j))
    #else:
        #cond_OT[j]=scistat.exponweib.fit(sub_OT)
        #plt.plot(xs,scistat.exponweib.pdf(xs,exp1,k1,loc1,lam1),'-r',label='weibull')
###########################################################################
###########  Generate data fit the distribution for frequency  ############
###########################################################################
frequency={}
for index, row in power_box.iterrows(): 

    if not any(not_used==index):

        mask=np.array(gmm_output[index]['centroids'].index[(np.max(gmm_output[index]['centroids'],axis=1)>row[1])&
            (np.max(gmm_output[index]['centroids'],axis=1)<row[2])])


        path=path2store+'/'+resolution+'/'+'houseID_{}-omp_{}-{}.pickle'.format(index,omp_tolerance,resolution)
        output=open(path, 'rb')
        resultDic = pickle.load(output)
        output.close()

        y_dict={}
        for k in range(number_of_components):
            print(k)
            temp=[]
            for j in resultDic.keys():
                if any(resultDic[j].REFIND==k):
                    if sum(resultDic[j].REFIND==k)>1:
                        print('block = '+str(j))
                        temp.extend(np.transpose(resultDic[j].Kcoef)[np.where(resultDic[j].REFIND==k)[0]].sum(axis=0))
                    else:
                        temp.extend(np.transpose(resultDic[j].Kcoef)[np.where(resultDic[j].REFIND==k)[0]].flatten())
                else:
                    temp.extend(np.zeros(len(resultDic[j].Kcoef)))
            y_dict[k]=temp

        y_df=pd.DataFrame(y_dict)

        activations=(y_df[mask].sum(axis=1).diff()>0)*1
        activations=np.array(activations.rolling(144).sum()[143:]/144)
        frequency[index]=activations[np.where(activations!=0)[0]]

all_freq_data=np.concatenate([frequency[i] for i in frequency.keys()])

#for j in range(4): plt.hist(np.concatenate([frequency[i] for i in np.fromiter(power.keys(), dtype=int)[np.where(np.array(power_size)==2)[0]]]),bins=20,alpha=0.5)



xss=np.linspace(0,0.2,500) 
#(exp1, k1, loc1, lam1)=scistat.exponweib.fit(all_freq_data,f0=0.5)
#plt.plot(xs,scistat.exponweib.pdf(xss,exp1,k1,loc1,lam1),'-r',label='weibull')
(u,s)=scistat.norm.fit(all_freq_data)
plt.plot(xs,scistat.norm.pdf(xs,u,s),'-g',label='normal')
(s_e,u_e,sc_e)=scistat.exponnorm.fit(all_freq_data)
plt.plot(xss,scistat.exponnorm.pdf(xss,s_e,u_e,sc_e),label='expnormal')
(s_f,u_f,sc_f)=scistat.lognorm.fit(all_freq_data)

distrib_f=scistat.expnorm.pdf(xss,s_e,u_e,sc_e)
plt.plot(xss,scistat.lognorm.pdf(xss,s_f,u_f,sc_f),'black',label='lognormal')
plt.hist(all_freq_data,density=True,bins=15)
plt.xlabel('Frequency')
plt.legend()

freq_distib={}
for j in range(5):
    sub_freq=np.concatenate([frequency[i] for i in [k for k, v in power_size.items() if v==j]])
    (s_fi,u_fi,sc_fi)=scistat.exponnorm.fit(sub_freq)
    freq_distib[j]=scistat.exponnorm.pdf(xss,s_fi,u_fi,sc_fi)
    plt.plot(xss,scistat.exponnorm.pdf(xss,s_fi,u_fi,sc_fi),label='power='+r'$\mu_{}$'.format(j+1))
    #KL_div.append(scistat.entropy(distrib_f,scistat.lognorm.pdf(xss,s_fi,u_fi,sc_fi)))
    plt.xlabel('Frequency')
    plt.legend()

KL_div={}
for index in frequency.keys():
    (s_fi,u_fi,sc_fi)=scistat.lognorm.fit(frequency[index])
    KL_div[index]=np.round(scistat.entropy(scistat.lognorm.pdf(xss,s_fi,u_fi,sc_fi),freq_distib[power_size[index]]),2)

x_kl=np.linspace(0,4,500)
(s_kl,u_kl,sc_kl)=scistat.lognorm.fit(np.array([v for k,v in KL_div.items()]))
plt.hist(np.array([v for k,v in KL_div.items()]),density=True) 
plt.plot(x_kl,scistat.lognorm.pdf(x_kl,s_kl,u_kl,sc_kl)) 
plt.xlabel('KL-divergent') 
#########################################################################################
#                                                                                       #
#------------- Extract power, OT and frequency for the remaining boxcar ----------------#
#                                                                                       #
#########################################################################################

raw_power=[]
raw_OT=[]
for index, row in power_box.iterrows(): 
    path=path2store+'/'+resolution+'/'+'houseID_{}-omp_{}-{}.pickle'.format(index,omp_tolerance,resolution)
    output=open(path, 'rb')
    resultDic = pickle.load(output)
    output.close()

    Kcoef_full = np.transpose(Kcoef_hstack_set(Xshape=1000, resultDic=resultDic))
    max_power=np.max(Kcoef_full,axis=1)
    for j in np.where((max_power<=row[1])|(max_power>=row[2]))[0]:
        raw_OT.extend([np.count_nonzero(Kcoef_full[j])])
        raw_power.extend([max_power[j]])

raw_power=np.array(raw_power)
(s_power_raw,u_power_raw,sc_power_raw)=scistat.lognorm.fit(raw_power)
#all_raw_lognormal=scistat.lognorm.pdf(xs,s_power_raw,u_power_raw,sc_power_raw)
#plt.plot(xs,all_raw_lognormal)

#mixture=np.sum(np.array([scistat.norm.pdf(xs,means_p[i],vars_p[i])*weights_p[i] for i in range(4)],axis=0))
plt.plot(xs,scistat.lognorm.pdf(xs,s_power_raw,u_power_raw,sc_power_raw))
plt.hist(raw_power)




raw_OT=np.log(np.array(raw_OT)*float(''.join(c for c in resolution if c.isdigit())))

(s_OT_raw,u_OT_raw,sc_OT_raw)=scistat.exponnorm.fit(raw_OT)
#scistat.lognorm.pdf(xs,s_OT_raw,u_OT_raw,sc_OT_raw)
plt.plot(xs,scistat.exponnorm.pdf(xs,s_OT_raw,u_OT_raw,sc_OT_raw))
(exp_OT_raw, k_OT_raw, loc_OT_raw, lam_OT_raw)=scistat.exponweib.fit(raw_OT)
#plt.plot(xs,scistat.exponweib.pdf(xs,exp_OT_raw, k_OT_raw, loc_OT_raw, lam_OT_raw),'-r',label='weibull')
plt.hist(raw_OT,density=True,bins=10)

to_keep_ot_raw=np.where((raw_power>1.5) & (raw_power<7.))[0]
sub_raw_power=raw_power[to_keep_ot_raw]
sub_raw_OT=raw_OT[to_keep_ot_raw]

power_size_raw=np.argmin(np.abs(np.array([sub_raw_power-i for i in means_p])),axis=0)


cond_OT_raw={}
for j in range(5): 
    sub_ot=np.log(np.array([sub_raw_OT[i] for i in np.where(power_size_raw==j)[0]])*5)
    plt.hist(sub_ot,bins=20,alpha=0.5,density=True)
    if j!=3:

        cond_OT[j]=scistat.lognorm.fit(sub_ot)
        #plt.plot(xs,scistat.lognorm.pdf(xs,s_ot,u_ot,sc_ot),label='lognormal'+str(j))
    else:
        cond_OT[j]=scistat.exponweib.fit(sub_ot)
        #plt.plot(xs,scistat.exponweib.pdf(xs,exp1,k1,loc1,lam1),'-r',label='weibull'+str(j))
#########################################################################################
#                                                                                       #
#--------- Test extract for power and OT with randomly picked households ---------------#
#                                                                                       #
#########################################################################################


houseID_all=np.array(group_participation['house_number'] )
random.seed(a=10, version=2)
houseID_rdm=houseID_all[random.sample(range(0,len(houseID_all)),100)]

houseID_rdm=np.delete(houseID_rdm,np.where(np.array([i in np.array(power_box.index) for i in houseID_rdm]))[0],None)

not_processed=[] 
for i in houseID_rdm: 
    try: 
        path=path2store+'/'+resolution+'/'+'houseID_{}-omp_{}-{}.pickle'.format(i,omp_tolerance,resolution)
        output=open(path, 'rb') 
        output.close()
    except FileNotFoundError: 
        not_processed.extend([i]) 

houseID_rdm=np.delete(houseID_rdm,np.where(np.array([i in np.array(not_processed) for i in houseID_rdm]))[0],None) # 12/75 households  len(np.where(np.array([i in houseID_HP for i in houseID_rdm]))[0]) 



output=open(path2store+'/'+resolution+'/'+'gmm_output_omp-{}-{}.pickle'.format(omp_tolerance,resolution),'rb')
gmm_output_test=pickle.load(output)
output.close()

proba_power={}
proba_OT={}
KL_div_test={}
for Hid in houseID_rdm:
    print(Hid)



    path=path2store+'/'+resolution+'/'+'houseID_{}-omp_{}-{}.pickle'.format(Hid,omp_tolerance,resolution)
    output=open(path, 'rb')
    resultDic = pickle.load(output)
    output.close()
    Kcoef_full =np.transpose(Kcoef_hstack_set(Xshape=1000, resultDic=resultDic))


    power_test_clust=np.max(gmm_output_test[Hid]['centroids'],axis=1)

    
    if any(power_test_clust>1.5):

        #large_power_clusters=np.where(power_test_clust>1.5)[0]

        cluster_size=Counter(gmm_output_test[Hid]['REFIND'])
        
        likelihood_power_clust=np.concatenate([scistat.norm.pdf(power_test_clust,means_p[0],vars_p[0]), #2.0                                                                       
        scistat.norm.pdf(power_test_clust,means_p[1],vars_p[1]) ,    #    2.6                                                                 
        scistat.norm.pdf(power_test_clust,means_p[2],vars_p[2]),    # 3.0                                                                      
        scistat.norm.pdf(power_test_clust,means_p[3],vars_p[3]) ,   #  4.0
        scistat.norm.pdf(power_test_clust,means_p[4],vars_p[4]) ,   #    5.0                                                              
        scistat.lognorm.pdf(power_test_clust,s_power_raw,u_power_raw,sc_power_raw)]).reshape((6,-1))
        proba_power_clust=likelihood_power_clust/np.sum(likelihood_power_clust,axis=0)
        
        highest_proba_power_clust=np.argmax(proba_power_clust,axis=0)
        mask_test={}
        for k in range(5):
            mask_test[k]=np.where(highest_proba_power_clust==k)[0]

       # mask_test={}
        #for k in range(5):
       #     mask_test[k]=np.array(gmm_output_test[Hid]['centroids'].index[(power_test>np.nanmin(means_p[k]-vars_p[k]))&(power_test<np.nanmax(means_p[k]+vars_p[k]))])
        
        power_to_test=np.argmax(np.array([sum([cluster_size[l] for l in mask_test[k]]) for k in mask_test.keys()]))

        all_power_test=np.concatenate([np.max(Kcoef_full[np.where(gmm_output_test[Hid]['REFIND']==j)[0]],axis=1)for j in mask_test[power_to_test]])
        all_OT_test=np.log(np.concatenate([np.count_nonzero(Kcoef_full[np.where(gmm_output_test[Hid]['REFIND']==j)[0]],axis=1)for j in mask_test[power_to_test]])*5)
        if len(all_power_test)>=10:
            #xs=np.linspace(0,7,500)
            #test_gaussian_ot=gaussian_kde(np.log(all_OT_test*5))

            #plt.plot(xs,test_gaussian_ot(xs),'-g',label='normal')
                
            #test_gaussian_power=gaussian_kde(all_power_test)
            #plt.plot(xs,test_gaussian_power(xs))


            #(u_ot_test,s_ot_test)=scistat.norm.fit(np.log(all_OT_test*5))
            #(u_power_test,s_power_test)=scistat.norm.fit(all_power_test)
            #=np.array([, , , ,])
            likelihood_power=np.concatenate([scistat.norm.pdf(all_power_test,means_p[0],vars_p[0]), #2.0                                                                      
            scistat.norm.pdf(all_power_test,means_p[1],vars_p[1]) ,    #    2.6                                                                
            scistat.norm.pdf(all_power_test,means_p[2],vars_p[2]),    # 3.0                                                                      
            scistat.norm.pdf(all_power_test,means_p[3],vars_p[3]) ,   #  4.0
            scistat.norm.pdf(all_power_test,means_p[4],vars_p[4]) ,   #    5.0                                                              
            scistat.lognorm.pdf(all_power_test,s_power_raw,u_power_raw,sc_power_raw)]).reshape((6,-1))
            
            proba_power[Hid]=likelihood_power/np.sum(likelihood_power,axis=0)
            highest_proba_power=Counter(np.argmax(proba_power[Hid],axis=0)).most_common(1)[0][0]
            
            
            #if highest_proba_power==5:
            #    L_HP=scistat.lognorm.pdf(all_OT_test,cond_OT[4][0],cond_OT[4][1],cond_OT[4][2])
            #else:
            #    L_HP=scistat.lognorm.pdf(all_OT_test,cond_OT[highest_proba_power][0],cond_OT[highest_proba_power][1],cond_OT[highest_proba_power][2])
            
            #likelihood_OT=np.concatenate([L_HP,scistat.exponweib.pdf(all_OT_test,exp_OT_raw, k_OT_raw, loc_OT_raw, lam_OT_raw)]).reshape((2,-1))
            likelihood_OT=np.concatenate([scistat.lognorm.pdf(all_OT_test,s_ot,u_ot,sc_ot),scistat.exponweib.pdf(all_OT_test,exp_OT_raw, k_OT_raw, loc_OT_raw, lam_OT_raw)]).reshape((2,-1))
            proba_OT[Hid]=likelihood_OT/np.sum(likelihood_OT,axis=0)
            highest_proba_OT=Counter(np.argmax(proba_OT[Hid],axis=0)).most_common(1)[0][0]
            
            y_dict={}
            for k in range(len(cluster_size)):
                #print(k)
                temp=[]
                for j in resultDic.keys():
                    if any(resultDic[j].REFIND==k):
                        if sum(resultDic[j].REFIND==k)>1:
                            #print('block = '+str(j))
                            temp.extend(np.transpose(resultDic[j].Kcoef)[np.where(resultDic[j].REFIND==k)[0]].sum(axis=0))
                        else:
                            temp.extend(np.transpose(resultDic[j].Kcoef)[np.where(resultDic[j].REFIND==k)[0]].flatten())
                    else:
                        temp.extend(np.zeros(len(resultDic[j].Kcoef)))
                y_dict[k]=temp

            y_df=pd.DataFrame(y_dict)

            activations=(y_df[mask_test[power_to_test]].sum(axis=1).diff()>0)*1
            activations=np.array(activations.rolling(144).sum()[143:]/144)
            (s_f_test,u_f_test,sc_f_test)=scistat.lognorm.fit(activations[np.where(activations!=0)[0]])
            if (highest_proba_power!=5) & (highest_proba_OT!=1):
                KL_div_test[Hid]=np.round(scistat.entropy(scistat.lognorm.pdf(xss,s_f_test,u_f_test,sc_f_test),freq_distib[highest_proba_power]),2)
            else:
                KL_div_test[Hid]=4
        else:
            proba_power[Hid]=np.array([0.,0.,0.,0.,1.]).reshape((-1,1))
            proba_OT[Hid]=np.array([0.,1.]).reshape((-1,1))
            KL_div_test[Hid]=4
    else:
        proba_power[Hid]=np.array([0.,0.,0.,0.,1.]).reshape((-1,1))
        proba_OT[Hid]=np.array([0.,1.]).reshape((-1,1))
        KL_div_test[Hid]=4
    #highest_proba_ot=Counter(np.argmax(proba_ot,axis=0))

    #if (Counter(np.argmax(proba_power[Hid],axis=0)).most_common(1)[0][0]!=4)&(Counter(np.argmax(proba_ot[Hid],axis=0)).most_common(1)[0][0]!=1):



np.where(np.array([Counter(np.argmax(proba_power[k],axis=0)).most_common(1)[0] for k in proba_power.keys()]).transpose()[0]!=5)[0]
np.where(np.array([Counter(np.argmax(proba_OT[k],axis=0)).most_common(1)[0] for k in proba_OT.keys()]).transpose()[0]!=1)[0]

power_HP={}
for k in proba_power.keys():
     power_HP[k]=pd.DataFrame({'mean':np.argmax(proba_power[k],axis=0),'proba':np.max(proba_power[k],axis=0)}) 


power_HP={}
for k in proba_power.keys():
    power_HP[k]=Counter(np.argmax(proba_power[k],axis=0)).most_common(1)[0]

OT_HP={}
for k in proba_power.keys():
    OT_HP[k]=Counter(np.argmax(proba_OT[k],axis=0)).most_common(1)[0]
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



#############################################################################################
##------------------- different test to get the power and OT prior ------------------------##
#############################################################################################
import random 
for i in range(1000): 
    xs=np.linspace(0,7,500) 
    power_data=np.array(power)[random.sample(range(0,len(power)),50)]
    density_power = gaussian_kde(power_data)
    if i==0: 
        all_power_data=power_data
        all_density_power=density_power(xs) 
    else: 
        all_power_data=np.vstack((all_power_data,power_data))
        all_density_power=np.vstack((all_density_power, density_power(xs))) 
    #plt.plot(xs,density_power(xs),'-b',alpha=0.5)                                                                                 

for per in zip([2.5,5,10,25],[97.5,95,90,75]):
    plt.fill_between(xs,np.nanpercentile(all_density_power,per[0],axis=0),np.nanpercentile(all_density_power,per[1],axis=0), color="#3F5D7D",alpha=0.3)
plt.plot(xs,np.mean(all_density_power,axis=0),'white')

(exp1, k1, loc1, lam1)=scistat.exponweib.fit(all_power_data,f0=5)
plt.plot(xs,scistat.exponweib.pdf(xs,exp1,k1,loc1,lam1),'-r',label='weibull')
(u,s)=scistat.norm.fit(all_power_data)
plt.plot(xs,scistat.norm.pdf(xs,u,s),'-g',label='normal')
(s,u,sc)=scistat.lognorm.fit(all_power_data)
plt.plot(xs,scistat.lognorm.pdf(xs,s,u,sc),'black',label='lognormal')
plt.hist(all_power_data,normed=True,bins=20)
plt.xlabel('Power [kW]')
plt.legend()
                              


for i in range(1000): 
    xs=np.linspace(0,6,500) 
    OT_data=np.log(np.array(OT)[random.sample(range(0,len(OT)),50)]*5)
    density_OT = gaussian_kde(OT_data)
    if i==0: 
        all_OT_data=OT_data
        all_density_OT=density_OT(xs) 
    else: 
        all_OT_data=np.append(all_OT_data,OT_data)
        all_density_OT=np.vstack((all_density_OT, density_OT(xs))) 
   # plt.plot(xs,density_OT(xs),'-b',alpha=0.5)                                                                                 

for per in zip([2.5,5,10,25],[97.5,95,90,75]):
    plt.fill_between(xs,np.nanpercentile(all_density_OT,per[0],axis=0),np.nanpercentile(all_density_OT,per[1],axis=0), color="#3F5D7D",alpha=0.3)
plt.plot(xs,np.mean(all_density_OT,axis=0),'white')


(exp1, k1, loc1, lam1)=scistat.exponweib.fit(all_OT_data,f0=5)
plt.plot(xs,scistat.exponweib.pdf(xs,exp1,k1,loc1,lam1),'-r',label='weibull')
(u,s)=scistat.norm.fit(all_OT_data)
plt.plot(xs,scistat.norm.pdf(xs,u,s),'-g',label='normal')
(s,u,sc)=scistat.lognorm.fit(all_OT_data)
plt.plot(xs,scistat.lognorm.pdf(xs,s,u,sc),'black',label='lognormal')
plt.hist(all_OT_data,normed=True,bins=20)
plt.xlabel('Operation Time [log(min)]')
plt.legend()

for i in range(1000): 
    freq_data=frequency[random.sample(range(0,len(frequency)),500)]
    density_freq = gaussian_kde(frequency[random.sample(range(0,len(frequency)),500)]) 
    if i==0:
        all_freq_data=freq_data
        all_density_freq=density_freq(xs) 
    else: 
        all_freq_data=np.append(all_freq_data,freq_data)
        all_density_freq=np.vstack((all_density_freq, density_freq(xs))) 


for per in zip([2.5,5,10,25],[97.5,95,90,75]):
    plt.fill_between(xs,np.nanpercentile(all_density_freq,per[0],axis=0),np.nanpercentile(all_density_freq,per[1],axis=0), color="#3F5D7D",alpha=0.3)
plt.plot(xs,np.mean(all_density_freq,axis=0),'white')


#############################################################################################
##-------------------multigaussian generation ------------------------##
#############################################################################################


xs=np.linspace(0,6,500) 
rho=np.corrcoef(all_power_data,all_OT_data)[0,1]
M=500
jointPrior={}
for k in range(4):
    jointPrior[k] = np.zeros((M, M))
    for i in range(M):
        for j in range(M):
            jointPrior[k][i,j]=1/(2*math.pi*vars_p[k]*s_ot*np.sqrt(1-np.power(rho,2)))*np.exp(-1/(2*(1-np.power(rho,2)))*(np.power((xs[i]-means_p[k]),2)/np.power(vars_p[k],2)+np.power((xs[j]-u_ot),2)/np.power(s_ot,2)-(2*rho*(xs[i]-means_p[k])*(xs[j]-u_ot))/(vars_p[k]*s_ot)))


for k in range(4):
    plt.contour(xs,xs,jointPrior[k])

plt.xlabel('Operation Time [log(min)]')
plt.ylabel('Power [kW]')


        jointPrior[i,j]=1/(2*pi*sigma1*sigma2*np.sqrt(1-np.power(rho,2)))*
        np.exp(-1/(2*(1-np.power(rho,2)))*(np.power((a[i]-mu1),2)/np.power(sigma1,2)+
        np.power((b[j]-mu2),2)/np.power(sigma2,2)-(2*rho*(a[i]-mu1)*(b[j]-mu2))/(sigma1*sigma2)))


Likelihoodmat = np.zeros((M, M))
rho_test=np.corrcoef(all_power_test,all_OT_test)[0,1]
for i in range(M):
    for j in range(M): 
      Likelihoodmat[i,j] = 1/(2*math.pi*s_power_test*s_ot_test*np.sqrt(1-np.power(rho,2)))*np.exp(-1/(2*(1-np.power(rho,2)))*(np.power((xs[i]-u_power_test),2)/np.power(s_power_test,2)+np.power((xs[j]-u_ot_test),2)/np.power(s_ot_test,2)-(2*rho*(xs[i]-u_power_test)*(xs[j]-u_ot_test))/(s_power_test*s_ot_test)))
Likelihoodmat[np.where(Likelihoodmat<1e-3)]=0.0

gmm_test=GaussianMixture(n_components=2,covariance_type='full').fit(all_power_test.reshape(-1,1))
u_power_test=gmm_test.means_[1][0]
s_power_test=gmm_test.covariances_[1][0][0]
plt.contour(xs,xs,Likelihoodmat)


#############################################################################
#############################################################################
############################################################################
path=path2store+'houseID_{}-omp_{}.pickle'.format(15675,omp_tolerance) 
output=open(path, 'rb') 
resultDic = pickle.load(output) 
output.close() 
xs=np.linspace(0,188*5,189)
f, axs = plt.subplots(2,1,figsize=(20,7.5), sharex='col', sharey='row')
f.subplots_adjust(hspace = .1, wspace=.05)
axs = axs.ravel()
length=188
axs[0].plot(xs[:length],resultDic[4].signal[:length],label='Original signal',linewidth=1.5)
axs[0].plot(xs[:length],resultDic[4].RecSignal[:length] ,alpha=0.75,label='Approximated signal',linewidth=1.5)
axs[0].set_ylabel('Power [kW]')
axs[0].legend()

axs[1].plot(xs[:length],resultDic[4].Kcoef[:length],linewidth=1.5,alpha=0.75) 
axs[1].set_xlabel('Time [min]')
axs[1].set_ylabel('Power [kW]')
axs[1].text(870, 2.5,'Boxcar functions', ha='left', va='center')